# Formation ‚Äî .NET Toolbox (C# / .NET)

> **Public** : d√©veloppeurs C#/.NET (junior √† confirm√©) souhaitant ma√Ætriser les ‚Äúoutils de base‚Äù et les bons r√©flexes.
>
> **Pr√©requis** : bases C# (types, m√©thodes, exceptions), IDE (Visual Studio / Rider / VS Code), notions de LINQ.
>
> **Dur√©e sugg√©r√©e** : 1 jour (7h) ou 2 demi‚Äëjourn√©es. 
>
> **Versions** : exemples compatibles .NET 8/9 (C# 12/13). 

---

## Objectifs p√©dagogiques

√Ä la fin de cette formation, vous serez capable de :

- Manipuler efficacement les cha√Ænes de caract√®res (performance, culture, Unicode).
- Utiliser les collections .NET adapt√©es (listes, dictionnaires, sets, queues, piles) et comprendre leurs complexit√©s.
- Ma√Ætriser `DateTime`, `DateTimeOffset`, `TimeSpan` et les conversions/formatages (fuseaux, UTC).
- G√©n√©rer et manipuler des `Guid` (identifiants) de fa√ßon correcte.
- Parser et valider des donn√©es (nombres, dates, bool, enum) avec `TryParse`, cultures, styles.
- Comprendre l‚ÄôUnicode (graphemes, normalisation, encodages) pour √©viter les bugs subtils.
- Utiliser `StringBuilder` et autres techniques pour optimiser la construction de texte.
- Formater proprement (interpolation, formats personnalis√©s, `IFormattable`, `Span`, `FormattableString`).

---

## Plan de la formation

1. **Introduction : la ‚Äútoolbox‚Äù .NET**
   - Panorama des namespaces utiles
   - Performance, allocation, immutabilit√©
   - Culture, invariance, s√©curit√©

2. **String handling (manipulation de cha√Ænes)**
   - Immutabilit√©, co√ªts d‚Äôallocation
   - Comparaisons (`StringComparison`, culture)
   - Recherche, d√©coupage, jointure
   - `Span<char>` / `ReadOnlySpan<char>` et `Memory<char>`

3. **Collections**
   - `List<T>`, `Array`, `Immutable*`
   - `Dictionary<TKey,TValue>`, `HashSet<T>`
   - `Queue<T>`, `Stack<T>`, `LinkedList<T>`
   - Choix de structure et complexit√©

4. **DateTime / DateTimeOffset / TimeSpan**
   - UTC vs Local vs Unspecified
   - Intervalles et arithm√©tique
   - Parsing/formatage et cultures
   - Horodatage robuste

5. **Guid**
   - G√©n√©ration, stockage, repr√©sentation (string)
   - Comparaison, parsing, formats
   - Bonnes pratiques (DB, logs)

6. **Parsing (TryParse, styles, validation)**
   - Nombres, dates, bool√©ens
   - `Enum.TryParse`
   - `CultureInfo`, `NumberStyles`, `DateTimeStyles`
   - Strat√©gies de validation

7. **Unicode**
   - UTF‚Äë16 dans .NET, `char` ‚â† ‚Äúcaract√®re utilisateur‚Äù
   - Surrogates, graphemes, normalisation
   - Comparaisons, casing, diacritiques

8. **StringBuilder et performance texte**
   - Quand l‚Äôutiliser (et quand l‚Äô√©viter)
   - `StringBuilder` vs interpolation vs `string.Create`
   - Pooling, `ValueStringBuilder` (concept)

9. **Formatting**
   - Interpolation, formats standards
   - Formats personnalis√©s (`DateTime`, numeric)
   - `IFormattable`, `ISpanFormattable`
   - `FormattableString` et internationalisation

10. **Atelier final : mini‚Äëoutil de parsing/formatage**
    - Import CSV simplifi√©
    - Validation, logs, mesures

---

# 1) Introduction : la ‚Äútoolbox‚Äù .NET

## 1.1 Namespaces indispensables

- `System` : types fondamentaux (`String`, `DateTime`, `Guid`, `Math`‚Ä¶)
- `System.Collections.Generic` : collections g√©n√©riques
- `System.Globalization` : `CultureInfo`, formats, comparaisons, parsing
- `System.Text` : `StringBuilder`, encodages, `Rune`
- `System.Text.RegularExpressions` : regex (utile mais √† utiliser prudemment)

## 1.2 Principes transverses

### Immutabilit√©

- `string` est **immutable** : toute modification cr√©e une **nouvelle** cha√Æne.
- Cons√©quence : concat√©nations r√©p√©t√©es dans une boucle peuvent √™tre co√ªteuses.

### Culture

- Beaucoup d‚ÄôAPI ont des comportements d√©pendants de la **culture** (ex : d√©cimales `,` vs `.`).
- R√®gle g√©n√©rale :
  - **donn√©es machine ‚Üî machine** : utiliser `CultureInfo.InvariantCulture`.
  - **UI/affichage utilisateur** : utiliser la culture courante (`CurrentCulture`).

### Performance / allocations

- Surveiller :
  - cr√©ation de nombreuses cha√Ænes temporaires
  - parsing/formatage dans des boucles
  - conversions inutiles

---

# 2) String handling (manipulation de cha√Ænes)

## 2.1 Immutabilit√© et co√ªts

```csharp
var s = "hello";
s += " world"; // cr√©e une nouvelle string
```

Si r√©p√©t√© N fois, cela peut amener une complexit√© quasi O(N¬≤) en copie.

## 2.2 Comparer des cha√Ænes correctement

### Ne pas faire

```csharp
if (a.ToLower() == b.ToLower()) { }
```

- Alloue de nouvelles cha√Ænes
- Probl√®mes culturels (ex : turc `I`/`ƒ±`)

### √Ä faire

```csharp
if (string.Equals(a, b, StringComparison.Ordinal))
{
    // comparaison binaire, rapide, recommand√©e pour identifiants
}

if (string.Equals(a, b, StringComparison.OrdinalIgnoreCase))
{
    // case-insensitive, invariant (ordinal)
}

if (string.Equals(a, b, StringComparison.CurrentCulture))
{
    // comparaison linguistique selon culture courante (UI)
}
```

**Recommandations** :
- Identifiants, cl√©s, protocoles, JSON, tokens : `Ordinal` / `OrdinalIgnoreCase`.
- Texte affich√© √† l‚Äôutilisateur : `CurrentCulture` / `CurrentCultureIgnoreCase`.

## 2.3 Recherche et extraction

### `Contains`, `StartsWith`, `EndsWith` avec `StringComparison`

```csharp
var input = "Bonjour CSharp";

bool has = input.Contains("csharp", StringComparison.OrdinalIgnoreCase);
bool starts = input.StartsWith("bon", StringComparison.CurrentCultureIgnoreCase);
```

### `IndexOf` / `LastIndexOf`

```csharp
int i = input.IndexOf('C');
int j = input.IndexOf("CSharp", StringComparison.Ordinal);
```

### `Substring` (√† utiliser avec prudence)

```csharp
var sub = input.Substring(8, 5);
```

‚ö†Ô∏è Cr√©e une nouvelle string. Pour √©viter des allocations sur des segments, pr√©f√©rer `AsSpan()`.

## 2.4 `Split` / `Join`

```csharp
var csv = "a,b,c";
string[] parts = csv.Split(',');

var joined = string.Join("; ", parts);
```

**Attention** : `Split` peut beaucoup allouer. Pour du haut d√©bit, envisager parsing via `Span`.

## 2.5 `Span<char>` pour r√©duire les allocations

### Exemple : extraire sans allouer (tant qu‚Äôon reste en `Span`)

```csharp
ReadOnlySpan<char> span = "2026-02-18".AsSpan();
var year = span.Slice(0, 4);   // pas d'allocation
var month = span.Slice(5, 2);
var day = span.Slice(8, 2);

// Pour afficher : conversion en string (allocation)
Console.WriteLine(year.ToString());
```

### Parsing num√©rique depuis un `Span`

```csharp
using System.Globalization;

ReadOnlySpan<char> yearSpan = "2026";
if (int.TryParse(yearSpan, NumberStyles.None, CultureInfo.InvariantCulture, out int year))
{
    // ok
}
```

---

# 3) Collections

## 3.1 Choisir la bonne collection (raccourci)

| Besoin | Structure | Notes | Complexit√© moyenne |
|---|---|---|---|
| S√©quence mutable | `List<T>` | append rapide, indexation | acc√®s O(1), ajout fin O(1) amorti |
| Tableau fixe | `T[]` | tr√®s performant, taille fixe | acc√®s O(1) |
| Cl√© ‚Üí valeur | `Dictionary<TKey,TValue>` | lookup rapide | O(1) amorti |
| Ensemble (unicit√©) | `HashSet<T>` | pas de doublons | O(1) amorti |
| FIFO | `Queue<T>` | file | Enqueue/Dequeue O(1) |
| LIFO | `Stack<T>` | pile | Push/Pop O(1) |
| Immutabilit√© | `ImmutableList<T>` etc. | thread-safe | co√ªts sp√©cifiques |

## 3.2 `List<T>` : capacit√© et performance

```csharp
var list = new List<int>(capacity: 10);
for (int i = 0; i < 1000; i++)
    list.Add(i);
```

**Point cl√©** : `List<T>` grandit par paliers (r√©allocations + copie). Si vous connaissez la taille, **pr√©allouez**.

### It√©ration

- `for` est souvent le plus performant.
- `foreach` est tr√®s bien dans la majorit√© des cas (optimis√©).

## 3.3 `Dictionary<TKey,TValue>` : cl√©s, comparers, collisions

```csharp
var dict = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
{
    ["alice"] = 1,
    ["Bob"] = 2,
};

Console.WriteLine(dict["ALICE"]); // 1
```

**Bonnes pratiques** :
- Pour des cl√©s `string`, choisir explicitement un `StringComparer`.
- √âviter de d√©pendre du comparer par d√©faut (peut √™tre `CurrentCulture` selon API).

### `TryGetValue`

```csharp
if (dict.TryGetValue("bob", out var value))
{
    // √©vite exception KeyNotFoundException
}
```

## 3.4 `HashSet<T>` : unicit√© et op√©rations d‚Äôensemble

```csharp
var a = new HashSet<int> { 1, 2, 3 };
var b = new HashSet<int> { 3, 4 };

a.UnionWith(b); // {1,2,3,4}
```

## 3.5 Collections immutables

Namespace : `System.Collections.Immutable`.

```csharp
using System.Collections.Immutable;

var imm = ImmutableList.Create(1, 2, 3);
var imm2 = imm.Add(4); // imm reste inchang√©e
```

Utiles pour :
- partage entre threads
- programmation fonctionnelle
- √©viter les effets de bord

---

# 4) DateTime / DateTimeOffset / TimeSpan

## 4.1 Le pi√®ge principal : `DateTimeKind`

`DateTime` transporte un `Kind` :
- `Utc`
- `Local`
- `Unspecified`

```csharp
DateTime nowLocal = DateTime.Now;      // Local
DateTime nowUtc = DateTime.UtcNow;     // Utc
```

### Recommandation

- Pour **stocker** un instant : privil√©gier **UTC**.
- Pour afficher √† l‚Äôutilisateur : convertir en local / timezone.

## 4.2 `DateTimeOffset` : souvent un meilleur ‚Äúinstant‚Äù

`DateTimeOffset` combine une date/heure + un offset.

```csharp
DateTimeOffset dto = DateTimeOffset.UtcNow;
Console.WriteLine(dto.Offset); // +00:00
```

**R√®gle** :
- Si vous manipulez des instants r√©els, `DateTimeOffset` aide √† √©viter des ambigu√Øt√©s.

## 4.3 `TimeSpan`

```csharp
var duration = TimeSpan.FromMinutes(90);
Console.WriteLine(duration.TotalSeconds);
```

## 4.4 Arithmetic et comparaison

```csharp
var start = DateTimeOffset.UtcNow;
var end = start.AddHours(2);
var elapsed = end - start; // TimeSpan
```

## 4.5 Parsing et formatage de dates

### Formatage invariant (logs, API)

```csharp
using System.Globalization;

var ts = DateTimeOffset.UtcNow;
string s = ts.ToString("O", CultureInfo.InvariantCulture); // ISO 8601 round-trip
```

### Parsing robuste

```csharp
using System.Globalization;

var text = "2026-02-18T10:00:00Z";
if (DateTimeOffset.TryParse(
        text,
        CultureInfo.InvariantCulture,
        DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal,
        out var parsed))
{
    // parsed en UTC
}
```

### Parse exact

```csharp
var text = "18/02/2026";
var fr = CultureInfo.GetCultureInfo("fr-FR");

if (DateTime.TryParseExact(text, "dd/MM/yyyy", fr,
    DateTimeStyles.None, out var dt))
{
}
```

---

# 5) Guid

## 5.1 G√©n√©rer

```csharp
Guid id = Guid.NewGuid();
```

## 5.2 Repr√©sentations (formats)

```csharp
var g = Guid.NewGuid();
Console.WriteLine(g.ToString("D")); // 32 digits separated by hyphens (d√©faut)
Console.WriteLine(g.ToString("N")); // 32 digits
Console.WriteLine(g.ToString("B")); // { ... }
Console.WriteLine(g.ToString("P")); // ( ... )
```

## 5.3 Parsing

```csharp
if (Guid.TryParse(input, out var guid))
{
    // ok
}

if (Guid.TryParseExact(input, "N", out var guidN))
{
}
```

## 5.4 Bonnes pratiques

- Stockage DB : type natif `uniqueidentifier` (SQL Server) / `uuid` (PostgreSQL).
- Logs/URLs : format `N` (compact) ou `D` (lisible).
- Comparaison : `Guid` est un struct, comparaison directe ok.

---

# 6) Parsing (TryParse, styles, validation)

## 6.1 Principe : pr√©f√©rer `TryParse`

- `Parse` l√®ve des exceptions (co√ªteux si fr√©quent).
- `TryParse` est pr√©dictible, adapt√© √† la validation.

## 6.2 Nombres et cultures

```csharp
using System.Globalization;

string priceText = "12.50";

bool ok = decimal.TryParse(priceText,
    NumberStyles.Number,
    CultureInfo.InvariantCulture,
    out decimal price);
```

### `NumberStyles`

- `NumberStyles.Integer` : entier (sign√©)
- `NumberStyles.Number` : d√©cimales + s√©parateurs
- `NumberStyles.AllowThousands` : s√©parateurs de milliers

## 6.3 Bool√©ens

```csharp
bool.TryParse("true", out var b1); // true
bool.TryParse("1", out var b2);    // false ("1" n'est pas reconnu)
```

Si vous devez accepter `0/1`, impl√©mentez une couche de parsing :

```csharp
static bool TryParseFlexibleBool(string s, out bool value)
{
    if (bool.TryParse(s, out value))
        return true;

    if (s == "0") { value = false; return true; }
    if (s == "1") { value = true; return true; }

    return false;
}
```

## 6.4 Enums

```csharp
enum LogLevel { Trace, Debug, Info, Warn, Error }

if (Enum.TryParse<LogLevel>("warn", ignoreCase: true, out var level))
{
}
```

**Conseil** : valider aussi que la valeur est d√©finie.

```csharp
if (Enum.TryParse<LogLevel>("123", out var level) && Enum.IsDefined(level))
{
}
```

## 6.5 Dates (rappel)

- Pr√©f√©rer `TryParseExact` quand le format est connu.
- Toujours sp√©cifier la culture si c‚Äôest un format ‚Äúmachine‚Äù.

---

# 7) Unicode

## 7.1 UTF‚Äë16 dans .NET : `char` ‚â† caract√®re utilisateur

En .NET :
- `string` est une s√©quence de **code units UTF‚Äë16**.
- `char` = 16 bits = **un code unit**, pas forc√©ment un caract√®re ‚Äúvisible‚Äù.

Exemple typique : certains emojis sont sur 2 `char` (surrogate pair).

```csharp
string s = "üòÄ";
Console.WriteLine(s.Length); // souvent 2
```

## 7.2 `Rune` pour manipuler des scalar values Unicode

```csharp
using System.Text;

foreach (var rune in "AüòÄB".EnumerateRunes())
{
    Console.WriteLine($"{rune} U+{rune.Value:X}");
}
```

## 7.3 Graphemes (texte tel que per√ßu)

Un ‚Äúcaract√®re‚Äù utilisateur peut √™tre :
- une lettre + diacritique combinant
- une s√©quence d‚Äôemojis (ZWJ)

Pour segmenter au niveau ‚Äútexte‚Äù, on peut utiliser `StringInfo` :

```csharp
using System.Globalization;

string text = "e\u0301"; // e + combining acute
var si = new StringInfo(text);
Console.WriteLine(si.LengthInTextElements); // 1
```

## 7.4 Normalisation

Deux cha√Ænes visuellement identiques peuvent √™tre diff√©rentes en binaire.

- NFC : forme compos√©e
- NFD : forme d√©compos√©e

```csharp
string a = "√©";           // U+00E9
string b = "e\u0301";     // e + combining acute

Console.WriteLine(a == b); // false

string an = a.Normalize(NormalizationForm.FormC);
string bn = b.Normalize(NormalizationForm.FormC);

Console.WriteLine(an == bn); // true
```

**Recommandation** : normaliser quand vous comparez/stocker des identifiants issus de saisie utilisateur.

## 7.5 Casing et culture

```csharp
var turkish = CultureInfo.GetCultureInfo("tr-TR");
Console.WriteLine("I".ToLower(turkish)); // 'ƒ±' (diff√©rent)
```

D‚Äôo√π la pr√©f√©rence pour `OrdinalIgnoreCase` pour identifiants.

---

# 8) StringBuilder et performance texte

## 8.1 Quand utiliser `StringBuilder`

Utilisez `StringBuilder` quand :
- vous concat√©nez **dans une boucle**
- vous ne connaissez pas la taille finale
- vous faites de nombreuses insertions/appends

```csharp
var sb = new StringBuilder();
for (int i = 0; i < 10_000; i++)
{
    sb.Append(i);
    sb.Append(';');
}
string result = sb.ToString();
```

### Pr√©allouer si possible

```csharp
var sb = new StringBuilder(capacity: 1024);
```

## 8.2 Quand NE PAS l‚Äôutiliser

- Concat√©nation de quelques √©l√©ments :

```csharp
string s = $"{firstName} {lastName}"; // simple et lisible
```

- Cha√Ænes constantes : le compilateur optimise souvent.

## 8.3 Alternatives

### Interpolation + `string.Create`

`string.Create` permet de construire une string en une allocation (sc√©narios avanc√©s).

```csharp
using System.Globalization;

static string FormatTwoDigits(int value)
{
    return string.Create(CultureInfo.InvariantCulture, stackalloc char[2], value,
        (span, v) =>
        {
            span[0] = (char)('0' + (v / 10));
            span[1] = (char)('0' + (v % 10));
        });
}
```

> √Ä r√©server aux cas performance critiques (sinon, la lisibilit√© prime).

---

# 9) Formatting

## 9.1 Interpolation (`$""`) et formats

```csharp
var price = 12.5m;
Console.WriteLine($"Price: {price:0.00}");
```

### Culture et interpolation

Par d√©faut : utilise `CurrentCulture`.

Pour forcer une culture :

```csharp
using System.Globalization;

var amount = 1234.56m;
var fr = CultureInfo.GetCultureInfo("fr-FR");

Console.WriteLine(string.Format(fr, "{0:N2}", amount));
```

## 9.2 Formats standards (principaux)

### Nombres

- `"N"` : number avec s√©parateurs
- `"F"` : fixed-point
- `"C"` : currency
- `"P"` : percent
- `"X"` : hex (entiers)

```csharp
int n = 255;
Console.WriteLine(n.ToString("X2")); // FF
```

### Dates

- `"O"` : round-trip ISO 8601 (recommand√© logs)
- `"s"` : sortable

```csharp
var dt = DateTimeOffset.UtcNow;
Console.WriteLine(dt.ToString("O"));
```

## 9.3 Formats personnalis√©s `DateTime`

```csharp
var dt = new DateTime(2026, 2, 18, 14, 30, 0);
Console.WriteLine(dt.ToString("yyyy-MM-dd HH:mm"));
```

## 9.4 `IFormattable` : rendre vos types formatables

```csharp
using System;
using System.Globalization;

public readonly record struct Money(decimal Amount, string Currency) : IFormattable
{
    public string ToString(string? format, IFormatProvider? formatProvider)
    {
        formatProvider ??= CultureInfo.CurrentCulture;
        format ??= "G";

        return format switch
        {
            "G" => string.Format(formatProvider, "{0} {1}", Amount, Currency),
            "ISO" => string.Format(CultureInfo.InvariantCulture, "{0:0.00} {1}", Amount, Currency),
            _ => throw new FormatException($"Unknown format '{format}'.")
        };
    }

    public override string ToString() => ToString("G", CultureInfo.CurrentCulture);
}

var m = new Money(12.5m, "EUR");
Console.WriteLine(m.ToString("ISO", null));
```

## 9.5 `FormattableString` pour i18n et logs

```csharp
FormattableString fs = $"User {userId} has {count} items";

// Rendu invariant (utile logs/telemetry)
string invariant = FormattableString.Invariant(fs);
```

---

# 10) Atelier final ‚Äî Mini import/validation (CSV simple)

## 10.1 √ânonc√©

Vous recevez un flux de lignes au format :

```text
Id;Name;BirthDate;Score
8393ff45163b427d92bb3842a65a0a07;Alice;2000-01-01;12.50
...
```

Objectifs :
- Parser un `Guid` (`Id`)
- Garder `Name` (normalisation/trim)
- Parser une date **invariante** (`yyyy-MM-dd`)
- Parser `Score` en `decimal` invariant
- Produire un rapport d‚Äôerreurs, sans exceptions en masse.

## 10.2 Mod√®le

```csharp
public sealed record PersonRow(Guid Id, string Name, DateOnly BirthDate, decimal Score);

public sealed record RowError(int LineNumber, string Message, string RawLine);
```

## 10.3 Impl√©mentation

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;

public static class CsvImporter
{
    public static (List<PersonRow> Rows, List<RowError> Errors) Import(IEnumerable<string> lines)
    {
        var rows = new List<PersonRow>();
        var errors = new List<RowError>();

        int lineNumber = 0;
        foreach (var line in lines)
        {
            lineNumber++;

            // Skip header (simple)
            if (lineNumber == 1 && line.StartsWith("Id;", StringComparison.OrdinalIgnoreCase))
                continue;

            if (string.IsNullOrWhiteSpace(line))
                continue;

            var parts = line.Split(';');
            if (parts.Length != 4)
            {
                errors.Add(new RowError(lineNumber, "Invalid column count", line));
                continue;
            }

            if (!Guid.TryParse(parts[0], out var id))
            {
                errors.Add(new RowError(lineNumber, "Invalid Guid", line));
                continue;
            }

            var name = parts[1].Trim();
            if (name.Length == 0)
            {
                errors.Add(new RowError(lineNumber, "Empty name", line));
                continue;
            }

            if (!DateOnly.TryParseExact(parts[2], "yyyy-MM-dd", CultureInfo.InvariantCulture,
                    DateTimeStyles.None, out var birthDate))
            {
                errors.Add(new RowError(lineNumber, "Invalid BirthDate (expected yyyy-MM-dd)", line));
                continue;
            }

            if (!decimal.TryParse(parts[3], NumberStyles.Number, CultureInfo.InvariantCulture, out var score))
            {
                errors.Add(new RowError(lineNumber, "Invalid Score", line));
                continue;
            }

            rows.Add(new PersonRow(id, name, birthDate, score));
        }

        return (rows, errors);
    }
}
```

## 10.4 Am√©liorations (discussion)

- Remplacer `Split` par un parsing `Span` pour limiter les allocations.
- G√©rer l‚Äô√©chappement CSV (guillemets) ou utiliser une librairie.
- Normaliser `Name` en Unicode NFC pour coh√©rence.
- Utiliser `DateTimeOffset` si vous traitez des instants avec fuseau.
- Ajouter un rapport texte via `StringBuilder`.

---

# Annexes ‚Äî Cheat sheet

## A) R√®gles d‚Äôor

- **Comparaison string** : toujours pr√©ciser `StringComparison`.
- **Donn√©es machine** : `InvariantCulture`.
- **Instants** : UTC (ou `DateTimeOffset`).
- **Validation** : `TryParse` plut√¥t que `Parse`.
- **Beaucoup de concat** : `StringBuilder`.
- **Unicode** : `char` n‚Äôest pas un caract√®re utilisateur ; attention aux normalisations.

## B) Exemples rapides

### Comparaison s√ªre

```csharp
bool same = string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
```

### Date ISO 8601

```csharp
string iso = DateTimeOffset.UtcNow.ToString("O", CultureInfo.InvariantCulture);
```

### Decimal invariant

```csharp
decimal.TryParse("12.50", NumberStyles.Number, CultureInfo.InvariantCulture, out var d);
```

### Guid compact

```csharp
string compact = Guid.NewGuid().ToString("N");
```

---

## Fin de la formation

Suggestions d‚Äô√©valuation :
- QCM sur `StringComparison`, `CultureInfo`, `DateTimeKind`.
- Kata : parse/format + rapport via `StringBuilder`, sans allocations inutiles.
- Revue de code : identifier les pi√®ges de culture/Unicode.
