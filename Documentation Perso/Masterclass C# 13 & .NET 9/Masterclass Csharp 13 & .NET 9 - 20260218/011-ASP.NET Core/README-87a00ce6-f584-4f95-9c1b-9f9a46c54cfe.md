# Formation ASP.NET Core (Masterclass .NET 9)

> **Public** : développeurs .NET/C# (débutant à intermédiaire sur le Web)  
> **Durée suggérée** : 2 à 3 jours (ou 12–18h)  
> **Pré-requis** : C# (POO, async/await), bases HTTP/REST, Visual Studio/VS Code, .NET SDK 9

---

## Objectifs pédagogiques

À l’issue de la formation, vous serez capable de :

- Expliquer l’architecture **ASP.NET Core** et les principes **MVC**.
- Construire un projet Web moderne avec le **pipeline middleware**.
- Utiliser efficacement l’**Injection de Dépendances (DI)** et la configuration.
- Mettre en place le **routing** (conventionnel et attributaire) et gérer la génération d’URLs.
- Comprendre et implémenter les bases de la **sécurité** (authentification, autorisation, validation, anti-forgery, headers, HTTPS).
- Appliquer les bonnes pratiques et tirer parti des **améliorations .NET 9**.

---

## Plan de la formation

1. [Introduction à ASP.NET Core](#1-introduction-à-aspnet-core)
2. [Architecture MVC](#2-architecture-mvc)
3. [Pipeline Middleware](#3-pipeline-middleware)
4. [Dependency Injection (DI)](#4-dependency-injection-di)
5. [Routing](#5-routing)
6. [Sécurité](#6-sécurité)
7. [Améliorations et nouveautés .NET 9 (et tendances)](#7-améliorations-et-nouveautés-net-9-et-tendances)
8. [Ateliers / Exercices guidés](#8-ateliers--exercices-guidés)
9. [Annexes : checklists & fiches mémo](#9-annexes--checklists--fiches-mémo)

---

# 1. Introduction à ASP.NET Core

## 1.1. ASP.NET Core en bref

ASP.NET Core est le framework serveur Web moderne de Microsoft pour construire :

- des applications Web (MVC, Razor Pages)
- des APIs (Minimal APIs, Controllers)
- des services temps réel (SignalR)
- des backends pour SPA (React/Angular/Vue)

Ses forces :

- **Cross-platform** (Windows/Linux/macOS)
- **Performant** (Kestrel, pipelines optimisés)
- **Modulaire** (middleware + DI)
- **Cloud-friendly** (containers, config par environnements)

## 1.2. Cycle de vie d’une requête

1. Le client envoie une requête HTTP.
2. Kestrel reçoit la requête.
3. La requête traverse le **pipeline middleware**.
4. Le **routing** sélectionne un endpoint.
5. MVC / endpoint exécute action, filtre, model binding, etc.
6. Une réponse est produite (HTML/JSON/etc.).
7. La réponse remonte (middlewares) et est envoyée au client.

## 1.3. Structure d’un projet (rappels)

- `Program.cs` : point d’entrée, configuration de services + pipeline.
- `appsettings.json` : configuration.
- `Controllers/`, `Views/` : MVC.
- `wwwroot/` : fichiers statiques.
- `Properties/launchSettings.json` : profils de lancement.

---

# 2. Architecture MVC

## 2.1. Pourquoi MVC ?

**MVC** sépare les responsabilités :

- **Model** : données + règles métier / validation.
- **View** : rendu HTML (Razor), présentation.
- **Controller** : orchestration, réception des requêtes, choix des réponses.

Bénéfices : testabilité, maintenabilité, clarté, évolution plus simple.

## 2.2. Le rôle des Controllers

Un controller est une classe (souvent suffixée par `Controller`) contenant des actions.

```csharp
using Microsoft.AspNetCore.Mvc;

public class ProductsController : Controller
{
    [HttpGet("/products")]
    public IActionResult Index()
        => View();

    [HttpGet("/products/{id:int}")]
    public IActionResult Details(int id)
        => View(model: id);
}
```

### Types de résultats (Action Results)

- `ViewResult` (`View(...)`) : HTML via Razor.
- `JsonResult` (`Json(...)`) : JSON.
- `ContentResult` (`Content(...)`) : texte.
- `RedirectResult` / `RedirectToAction`.
- `StatusCodeResult` (`NotFound()`, `BadRequest()`, `Unauthorized()`, etc.).

## 2.3. Le Model Binding

Le **model binding** construit des paramètres/objets à partir de :

- route (`/products/12`)
- query string (`?page=2`)
- headers
- body (JSON/form) selon le type de controller/API

Exemple :

```csharp
public record CreateProductRequest(string Name, decimal Price);

[HttpPost("/products")]
public IActionResult Create([FromBody] CreateProductRequest request)
{
    // request.Name / request.Price
    return Created("/products/123", null);
}
```

## 2.4. Validation (Data Annotations)

```csharp
using System.ComponentModel.DataAnnotations;

public class RegisterViewModel
{
    [Required, EmailAddress]
    public string Email { get; set; } = "";

    [Required, MinLength(8)]
    public string Password { get; set; } = "";
}
```

Dans une action MVC :

```csharp
[HttpPost]
public IActionResult Register(RegisterViewModel model)
{
    if (!ModelState.IsValid)
        return View(model);

    // Enregistrer l'utilisateur
    return RedirectToAction("Index", "Home");
}
```

## 2.5. Vues Razor

### Syntaxe de base

- `@model`: type du modèle
- `@{ }`: bloc C#
- `@if`, `@foreach`: structures

```cshtml
@model int
<h1>Détails produit</h1>
<p>Id : @Model</p>
```

### Layouts & partials

Bonnes pratiques :

- Layout pour structure globale (`_Layout.cshtml`)
- Partials `@await Html.PartialAsync("_ProductCard", item)`
- ViewComponents pour composants réutilisables avec logique

## 2.6. Filtres (Filters)

Les filtres permettent d’injecter des comportements autour d’une action :

- Authorization filters
- Resource filters
- Action filters
- Exception filters
- Result filters

Exemple d’action filter :

```csharp
using Microsoft.AspNetCore.Mvc.Filters;

public class LogActionFilter : IActionFilter
{
    private readonly ILogger<LogActionFilter> _logger;

    public LogActionFilter(ILogger<LogActionFilter> logger)
        => _logger = logger;

    public void OnActionExecuting(ActionExecutingContext context)
        => _logger.LogInformation("Executing {Action}", context.ActionDescriptor.DisplayName);

    public void OnActionExecuted(ActionExecutedContext context)
        => _logger.LogInformation("Executed {Action}", context.ActionDescriptor.DisplayName);
}
```

Enregistrement :

```csharp
builder.Services.AddControllersWithViews(options =>
{
    options.Filters.Add<LogActionFilter>();
});
```

---

# 3. Pipeline Middleware

## 3.1. Concept

Le pipeline est une **chaîne** de middlewares exécutés dans l’ordre.

Un middleware peut :

- traiter la requête avant les suivants
- appeler `next()`
- traiter la réponse au retour
- court-circuiter (ne pas appeler `next()`)

## 3.2. Exemple de pipeline minimal

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapDefaultControllerRoute();

app.Run();
```

### Ordre critique

- `UseRouting()` **avant** `UseAuthorization()`
- `UseAuthentication()` généralement avant `UseAuthorization()`
- `Map...` (endpoints) en fin de pipeline

## 3.3. Middlewares courants

- `UseExceptionHandler` / `UseDeveloperExceptionPage`
- `UseHsts`, `UseHttpsRedirection`
- `UseStaticFiles`
- `UseRouting`
- `UseCors`
- `UseAuthentication`, `UseAuthorization`
- `UseResponseCompression`

## 3.4. Écrire un middleware

### Version simple (inline)

```csharp
app.Use(async (context, next) =>
{
    var start = DateTimeOffset.UtcNow;
    await next();
    var elapsed = DateTimeOffset.UtcNow - start;

    context.Response.Headers["X-Elapsed-ms"] = elapsed.TotalMilliseconds.ToString("0");
});
```

### Version type dédiée

```csharp
public class RequestIdMiddleware
{
    private readonly RequestDelegate _next;

    public RequestIdMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.Headers["X-Request-Id"] = Guid.NewGuid().ToString();
        await _next(context);
    }
}

// Enregistrement
app.UseMiddleware<RequestIdMiddleware>();
```

## 3.5. Gestion d’erreurs

En dev : page détaillée.

En prod : page neutre + logs.

```csharp
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
```

---

# 4. Dependency Injection (DI)

## 4.1. Principe

ASP.NET Core fournit un conteneur DI intégré.

Objectifs :

- réduire les couplages
- faciliter tests et mocking
- centraliser la config

## 4.2. Durées de vie (lifetimes)

- **Transient** : nouvelle instance à chaque résolution
- **Scoped** : une instance par requête HTTP
- **Singleton** : une instance pour toute l’application

```csharp
builder.Services.AddTransient<IMailer, SmtpMailer>();
builder.Services.AddScoped<IUnitOfWork, EfUnitOfWork>();
builder.Services.AddSingleton<ISystemClock, SystemClock>();
```

> Bonnes pratiques :
> - Utiliser `Scoped` pour ce qui dépend du contexte requête (DbContext).
> - Éviter de résoudre un service `Scoped` depuis un `Singleton`.

## 4.3. Injection dans Controllers et autres composants

```csharp
public class OrdersController : Controller
{
    private readonly IOrderService _service;

    public OrdersController(IOrderService service)
        => _service = service;

    public IActionResult Index() => View(_service.GetAll());
}
```

Injection dans une action (plus rare, utile ponctuellement) :

```csharp
public IActionResult Health([FromServices] ILogger<OrdersController> logger)
{
    logger.LogInformation("Health checked");
    return Ok();
}
```

## 4.4. Options pattern (configuration typée)

`appsettings.json` :

```json
{
  "Smtp": {
    "Host": "smtp.example.com",
    "Port": 587
  }
}
```

C# :

```csharp
public class SmtpOptions
{
    public string Host { get; set; } = "";
    public int Port { get; set; }
}

builder.Services.Configure<SmtpOptions>(builder.Configuration.GetSection("Smtp"));
```

Usage :

```csharp
using Microsoft.Extensions.Options;

public class SmtpMailer(IOptions<SmtpOptions> options)
{
    private readonly SmtpOptions _options = options.Value;
}
```

## 4.5. HttpClientFactory

Éviter `new HttpClient()` partout.

```csharp
builder.Services.AddHttpClient("github", c =>
{
    c.BaseAddress = new Uri("https://api.github.com/");
    c.DefaultRequestHeaders.UserAgent.ParseAdd("demo-app");
});

// usage
public class GithubClient(IHttpClientFactory factory)
{
    public async Task<string> GetAsync()
    {
        var client = factory.CreateClient("github");
        return await client.GetStringAsync("");
    }
}
```

---

# 5. Routing

## 5.1. Routing : notions

Le routing en ASP.NET Core associe une URL à un endpoint.

- **Route templates** : `"/products/{id:int}"`
- **Contraintes** : `int`, `guid`, `regex(...)`
- **Defaults** : controller/action/id

## 5.2. Routing conventionnel (MVC)

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

## 5.3. Routing attributaire

```csharp
[Route("products")]
public class ProductsController : Controller
{
    [HttpGet("")]
    public IActionResult Index() => View();

    [HttpGet("{id:int}")]
    public IActionResult Details(int id) => View(id);
}
```

## 5.4. Génération d’URL

Éviter d’assembler les URLs à la main.

- `Url.Action("Details", "Products", new { id = 42 })`
- Tag helpers :

```cshtml
<a asp-controller="Products" asp-action="Details" asp-route-id="42">Détails</a>
```

## 5.5. Routing avancé : contraintes et segments

```csharp
[HttpGet("/files/{name}.{ext}")]
public IActionResult File(string name, string ext) => Ok(new { name, ext });

[HttpGet("/orders/{id:guid}")]
public IActionResult ById(Guid id) => Ok(id);
```

---

# 6. Sécurité

## 6.1. Menaces courantes (web)

- Injection (SQL, command, etc.)
- XSS
- CSRF
- Session hijacking
- Leakage de secrets
- Mauvaise configuration CORS
- Absence HTTPS / headers

## 6.2. HTTPS, HSTS et redirection

```csharp
app.UseHttpsRedirection();
app.UseHsts();
```

## 6.3. Authentification vs Autorisation

- **Authentification** : qui est l’utilisateur ? (cookies, JWT, OAuth)
- **Autorisation** : a-t-il le droit ? (roles, policies)

## 6.4. Authentification Cookie (web MVC)

Principe : session côté serveur + cookie sécurisé.

Configuration (exemple conceptuel) :

```csharp
builder.Services
    .AddAuthentication("Cookies")
    .AddCookie("Cookies", options =>
    {
        options.LoginPath = "/account/login";
        options.AccessDeniedPath = "/account/denied";
        options.Cookie.HttpOnly = true;
        options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
    });

app.UseAuthentication();
app.UseAuthorization();
```

Autorisation :

```csharp
[Authorize]
public IActionResult Profile() => View();

[Authorize(Roles = "Admin")]
public IActionResult Admin() => View();
```

## 6.5. Authentification JWT Bearer (API)

Approche typique :

- le client obtient un token (OAuth2/OpenID Connect ou login)
- le client envoie `Authorization: Bearer <token>`
- l’API valide signature/issuer/audience

> L’implémentation complète dépend du fournisseur d’identité (Entra ID, IdentityServer, etc.).

## 6.6. Autorisation par Policies

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("CanReadReports", p =>
        p.RequireClaim("scope", "reports.read"));
});

[Authorize(Policy = "CanReadReports")]
public IActionResult Reports() => View();
```

## 6.7. Protection CSRF (Anti-forgery)

En MVC (formulaires), activer et utiliser le token anti-forgery.

Dans les vues :

```cshtml
<form asp-action="Update">
    @Html.AntiForgeryToken()
    <!-- champs -->
</form>
```

Sur l’action :

```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Update(MyModel model) { ... }
```

## 6.8. Prévention XSS et encodage

- Razor encode par défaut en HTML.
- Éviter `@Html.Raw(...)` sauf contenu sûr.
- Valider/normaliser les entrées.

## 6.9. CORS (API)

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("spa", p =>
        p.WithOrigins("https://app.example.com")
         .AllowAnyHeader()
         .AllowAnyMethod());
});

app.UseCors("spa");
```

## 6.10. Protection des secrets

- Ne pas committer les secrets.
- Utiliser :
  - `dotnet user-secrets` en dev
  - variables d’environnement
  - vault (Azure Key Vault, etc.)

---

# 7. Améliorations et nouveautés .NET 9 (et tendances)

> **Note** : les fonctionnalités exactes peuvent évoluer selon la version finale et les SDK installés. L’objectif ici est de couvrir les tendances et améliorations majeures apportées par l’écosystème .NET récent (8 → 9) et leur impact sur ASP.NET Core.

## 7.1. Performance & diagnostics

- Améliorations continues de performance (allocations réduites, throughput).
- `ILogger` + structured logging : bonnes pratiques.
- `dotnet-counters`, `dotnet-trace`, OpenTelemetry.

## 7.2. Minimal hosting model et clarté de `Program.cs`

Le modèle moderne (introduit en .NET 6) est désormais standard :

- configuration centralisée dans `Program.cs`
- services + pipeline lisibles
- top-level statements

## 7.3. JSON, endpoints et ergonomie

- Utilisation accrue d’APIs plus concises.
- Bonnes pratiques autour de `System.Text.Json` (naming policies, `JsonSerializerOptions`).

## 7.4. Sécurité : durcissement par défaut

- Meilleures pratiques HTTPS/cookies.
- Headers de sécurité (à configurer)
- Facilitation d’intégration OAuth/OIDC selon templates/outils.

## 7.5. Templates et productivité

- Templates plus guidés.
- Meilleure intégration du front moderne (selon templates).

---

# 8. Ateliers / Exercices guidés

## Atelier 1 — Créer une application MVC

**Objectif** : générer un projet, comprendre la structure, exécuter.

1. Créer un projet : `dotnet new mvc -n Store.Web`
2. Explorer `Program.cs`, `Controllers`, `Views`, `wwwroot`
3. Ajouter un `ProductsController` et une vue `Index`.

**Critères de réussite** : une page `/products` affiche du contenu Razor.

## Atelier 2 — Ajouter un service métier via DI

**Objectif** : maîtriser les lifetimes et l’injection.

- Créer `IProductService` + implémentation mémoire.
- Enregistrer en `Scoped`.
- Injecter dans le controller.

**Bonus** : injecter `ILogger<T>` et produire des logs structurés.

## Atelier 3 — Écrire un middleware

**Objectif** : comprendre `next()` et l’ordre.

- Middleware `RequestIdMiddleware`.
- Ajouter un header `X-Request-Id`.
- Vérifier avec DevTools.

## Atelier 4 — Routing avancé

**Objectif** : contraintes, génération d’URL.

- Route `products/{id:int}`.
- Tag helpers pour générer des liens.

## Atelier 5 — Sécuriser une zone (/admin)

**Objectif** : authentication/authorization.

- Mettre en place une auth cookie simple.
- Ajouter `[Authorize]`.
- Interdire l’accès non authentifié.

> En contexte réel, privilégier OIDC avec un fournisseur d’identité.

---

# 9. Annexes : checklists & fiches mémo

## 9.1. Checklist pipeline

- [ ] `UseExceptionHandler` en production
- [ ] `UseHsts` + `UseHttpsRedirection`
- [ ] `UseStaticFiles` si nécessaire
- [ ] `UseRouting()` avant auth
- [ ] `UseAuthentication()`
- [ ] `UseAuthorization()`
- [ ] `MapControllers()` / `MapDefaultControllerRoute()` en fin

## 9.2. Checklist DI

- [ ] `DbContext` en `Scoped`
- [ ] éviter scoped dans singleton
- [ ] éviter locator pattern (`IServiceProvider` partout)
- [ ] options pattern pour config

## 9.3. Checklist sécurité

- [ ] HTTPS partout
- [ ] cookies `HttpOnly` + `Secure`
- [ ] CSRF token pour POST MVC
- [ ] CORS strict (pas `AllowAnyOrigin` en prod)
- [ ] validation des entrées
- [ ] secrets hors repo

---

## Fin de la formation

Suggestions de suite :

- ASP.NET Core Web API (controllers vs Minimal APIs)
- Entity Framework Core (accès aux données)
- Identity/OIDC avancé
- Observabilité (OpenTelemetry)
- Déploiement (Docker + CI/CD)
